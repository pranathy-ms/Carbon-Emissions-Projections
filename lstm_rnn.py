# -*- coding: utf-8 -*-
"""LSTM-RNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V_V7o_ylCCInKmAxd1sDRNui3LzsR5EQ
"""

import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import LSTM, Dense, Dropout, Input
from keras.optimizers import Adam
from sklearn.metrics import mean_squared_error, mean_absolute_error
import numpy as np
import matplotlib.pyplot as plt

#data = pd.read_csv(r'C:\Users\saiki\Desktop\CS584-Project Phase II\ghg-emissions-by-sector-stacked.csv')
data = pd.read_csv("sample_data/ghg-emissions-by-sector-stacked.csv")

sector_columns = [
    'Greenhouse gas emissions from other fuel combustion',
    'Greenhouse gas emissions from bunker fuels',
    'Greenhouse gas emissions from waste',
    'Greenhouse gas emissions from buildings',
    'Greenhouse gas emissions from industry',
    'Fugitive emissions of greenhouse gases from energy production',
    'Greenhouse gas emissions from agriculture',
    'Greenhouse gas emissions from manufacturing and construction',
    'Greenhouse gas emissions from transport',
    'Greenhouse gas emissions from electricity and heat'
]

global_emissions_by_sector = data.groupby('Year')[sector_columns].sum() / 1e6

def create_dataset(dataset, time_step=1):
    dataX, dataY = [], []
    for i in range(len(dataset) - time_step - 1):
        dataX.append(dataset[i:(i + time_step), 0])
        dataY.append(dataset[i + time_step, 0])
    return np.array(dataX), np.array(dataY)

def predict_future_emissions(model, last_sequence, num_years, scaler, time_step):
    predictions = []
    current_sequence = last_sequence.copy()

    for _ in range(num_years):
        next_emission = model.predict(current_sequence.reshape(1, time_step, 1))
        predictions.append(next_emission[0, 0])
        current_sequence = np.append(current_sequence[1:], next_emission, axis=0)

    return scaler.inverse_transform(np.array(predictions).reshape(-1, 1))

num_future_years = 10
time_step = 3

future_predictions = {}
actual_vs_predicted = {}
mse_values, rmse_values, mae_values = {}, {}, {}

epochs = 200
learning_rate = 0.001
dropout_rate = 0.2

for sector in sector_columns:

    sector_data = global_emissions_by_sector[[sector]]
    scaler = MinMaxScaler(feature_range=(0, 1))
    scaled_sector_data = scaler.fit_transform(sector_data)

    X, y = create_dataset(scaled_sector_data, time_step)
    X = X.reshape((X.shape[0], time_step, 1))

    train_size = int(len(X) * 0.8)
    X_train, X_test = X[:train_size], X[train_size:]
    y_train, y_test = y[:train_size], y[train_size:]

    model = Sequential()
    model.add(Input(shape=(time_step, 1)))  # Explicit input layer
    model.add(LSTM(64, return_sequences=True))
    model.add(Dropout(dropout_rate))
    model.add(LSTM(64, return_sequences=False))
    model.add(Dropout(dropout_rate))
    model.add(Dense(1))

    optimizer = Adam(learning_rate=learning_rate)

    model.compile(optimizer=optimizer, loss='mean_squared_error')

    model.fit(X_train, y_train, epochs=epochs, batch_size=1, verbose=0)

    y_pred = model.predict(X_test)

    y_pred_actual = scaler.inverse_transform(y_pred)
    y_test_actual = scaler.inverse_transform(y_test.reshape(-1, 1))

    mse = mean_squared_error(y_test_actual, y_pred_actual)
    rmse = np.sqrt(mse)
    mae = mean_absolute_error(y_test_actual, y_pred_actual)

    mse_values[sector] = mse
    rmse_values[sector] = rmse
    mae_values[sector] = mae

    last_sequence = scaled_sector_data[-time_step:]
    future_emissions = predict_future_emissions(model, last_sequence, num_future_years, scaler, time_step)
    future_predictions[sector] = future_emissions

    actual_vs_predicted[sector] = (y_test_actual, y_pred_actual)

for sector in sector_columns:
    print(f"{sector}")
    print(f"Mean Squared Error (MSE):  {mse_values[sector]:.2f}")
    print(f"Root Mean Squared Error (RMSE): {rmse_values[sector]:.2f}")
    print(f"Mean Absolute Error (MAE):  {mae_values[sector]:.2f}")
    print("-" * 40)

years = np.arange(global_emissions_by_sector.index[-1] + 1, global_emissions_by_sector.index[-1] + num_future_years + 1)

# Plot actual vs predicted for each sector
fig, ax2 = plt.subplots(figsize=(12, 8))

for sector in sector_columns:
    y_test_actual, y_pred_actual = actual_vs_predicted[sector]
    ax2.plot(np.arange(len(y_test_actual)), y_test_actual, label=f"Actual: {sector}", linestyle='-', linewidth=2)
    ax2.plot(np.arange(len(y_pred_actual)), y_pred_actual, label=f"Predicted: {sector}", linestyle='--')

ax2.set_title('Actual vs Predicted Emissions by Sector', fontsize=16)
ax2.set_xlabel('Time Steps', fontsize=12)
ax2.set_ylabel('Emissions (million tonnes)', fontsize=12)
ax2.legend(loc='upper left', bbox_to_anchor=(1.05, 1), title="Sector")
ax2.grid(True)

plt.tight_layout()
plt.show()

# Plot future predictions stacked area chart
fig, ax1 = plt.subplots(figsize=(12, 8))

ax1.stackplot(global_emissions_by_sector.index, global_emissions_by_sector.T, labels=sector_columns)
ax1.set_title('Global Greenhouse Gas Emissions by Sector (1990-2020)', fontsize=16)
ax1.set_xlabel('Year', fontsize=12)
ax1.set_ylabel('Emissions (million tonnes)', fontsize=12)
ax1.legend(loc='upper left', bbox_to_anchor=(1.05, 1), title="Sector")
ax1.grid(True)

for sector in sector_columns:
    ax1.plot(years, future_predictions[sector], label=f"Predicted Future: {sector}", linestyle='--')

plt.tight_layout()
plt.show()